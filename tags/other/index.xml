<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Other on Raphael Schmitt — AI Researcher | Language Models, NLP &amp; Information Retrieval</title><link>/tags/other/</link><description>Recent content in Other on Raphael Schmitt — AI Researcher | Language Models, NLP &amp; Information Retrieval</description><generator>Source Themes academia (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright &amp;copy; {year}</copyright><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/other/index.xml" rel="self" type="application/rss+xml"/><item><title>Volume Renderer for use with MATLAB</title><link>/project/volume-renderer/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>/project/volume-renderer/</guid><description>&lt;h2 id="from-a-student-project-to-a-polished-tool-gpu-volume-rendering-for-matlab">From a student project to a polished tool: GPU volume rendering for MATLAB&lt;/h2>
&lt;p>Volume Renderer for use with MATLAB started as my master project at the University of Freiburg in 2012, supervised by Benjamin Ummenhofer and apl. Prof. Dr. Olaf Ronneberger. At the time, MATLAB offered only limited support for interactive, high quality volume rendering of 3D data on the GPU, especially for larger medical volumes and multi volume scenes. The project filled this gap by adding a GPU enabled volume render command to MATLAB that could be used directly from scripts and applications.&lt;/p>
&lt;p>The core renderer is written in CUDA C and C++, while the user interface is provided through a set of MATLAB classes. This design separates performance critical code from user facing logic and allowed us to integrate advanced rendering concepts into a familiar MATLAB workflow. Users can call the renderer like any other MATLAB function, yet the heavy lifting happens on the GPU.&lt;/p>
&lt;p>A central feature of the system is its custom memory management. GPU memory is limited, but many use cases require rendering multiple large volumes in a single scene. To address this, the renderer splits the scene into separate rendering passes that fit into GPU memory, then combines the resulting images inside MATLAB into a single final frame. On top of that, volumes are only transferred to the GPU when the underlying data changes, which keeps repeated renders fast by reusing GPU memory across calls.&lt;/p>
&lt;p>The renderer also implements a generic illumination model that can be extended with different phase functions. The provided implementation uses the Henyey Greenstein phase function, which allows realistic lighting effects for volumetric data. For specific applications the tool supports off axis stereo rendering, which makes it possible to create stereo pairs and 3D movies for immersive visualization.&lt;/p>
&lt;p>High usability was a design goal from the beginning. The MATLAB interface is built around a small set of classes that make it straightforward to configure scenes, adjust parameters, and generate animations programmatically. This makes the renderer suitable not only for research prototypes, but also for teaching and reproducible figure generation.&lt;/p>
&lt;p>After an initial active phase during my studies the project sat idle for several years. When I moved to Munich in 2021 I resumed work on the codebase, updated the toolchain, improved the documentation, and prepared the project for a proper open source release. The result was a journal publication in 2024 and a cleaned up public repository that others can build on.&lt;/p>
&lt;p>Volume Renderer for use with MATLAB is released under the GNU Affero General Public License version 3. The example scripts are licensed under MIT, so they can be easily reused and adapted. The full source code is available on GitHub, together with usage examples and build instructions.&lt;/p>
&lt;hr>
&lt;h2 id="links-and-resources">Links and Resources&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Journal Publication (2024):&lt;/strong>&lt;br>
&lt;a href="https://www.mdpi.com/2673-6470/4/4/49">https://www.mdpi.com/2673-6470/4/4/49&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GitHub Repository:&lt;/strong>&lt;br>
&lt;a href="https://github.com/raphiniert-com/volume_renderer">https://github.com/raphiniert-com/volume_renderer&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>React Admin Data Providers</title><link>/project/ra-data/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>/project/ra-data/</guid><description>&lt;h2 id="react-admin-data-providers-for-clinical-apis--postgrest-and-fhir">React Admin Data Providers for Clinical APIs – PostgREST and FHIR&lt;/h2>
&lt;p>The development of my React Admin data providers began with the MeSH Browser project. At that time, I needed a flexible way to connect a React Admin frontend to a PostgREST backend without manually wiring every query, filter and pagination step. Early community work provided some inspiration, but no complete implementation existed. This led to the first version of the PostgREST data provider, which gradually grew into a fully featured library which is widely used (&amp;gt;2k downloads/week).&lt;/p>
&lt;p>Over time, the project evolved far beyond its original prototype. We added a dedicated test framework, introduced structured configuration, and turned it into a generic ecosystem that makes it easy to build React Admin frontends on top of Postgres. A demo setup was created to showcase multiple PostgreSQL FDWs together with PostgREST, illustrating how flexible the architecture can be when connecting diverse data sources. For authentication and authorization, the system integrates cleanly with Keycloak.&lt;/p>
&lt;p>The second data provider emerged in a similar way. As part of a student project, we built a FHIR REST data provider for React Admin. Its goal was to simplify building clinical user interfaces directly on top of FHIR servers. The data provider implements FHIR search, pagination, resource handling and bundle interpretation, and was tested against the LinuxForHealth (formerly IBM) FHIR Server. Together with a small demo application, this demonstrated how React Admin can be used as a lightweight tool for building FHIR based administrative interfaces. The project resulted in a peer reviewed conference publication at ICIMTH.&lt;/p>
&lt;p>Together, these two libraries form a small but valuable toolkit that connects modern React based user interfaces with established clinical APIs. Whether through PostgREST or FHIR, both data providers lower the barrier for creating custom user interfaces in clinical or research environments by offering reliable, clean and reusable integrations that work out of the box.&lt;/p>
&lt;hr>
&lt;h2 id="links--resources">Links &amp;amp; Resources&lt;/h2>
&lt;h3 id="postgrest-data-provider">PostgREST Data Provider&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Journal Publication (Software Impacts, 2024):&lt;/strong>&lt;br>
&lt;a href="https://www.sciencedirect.com/science/article/pii/S2665963824000873">https://www.sciencedirect.com/science/article/pii/S2665963824000873&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>NPM Package:&lt;/strong>&lt;br>
&lt;a href="https://www.npmjs.com/package/@raphiniert/ra-data-postgrest">https://www.npmjs.com/package/@raphiniert/ra-data-postgrest&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GitHub Repository:&lt;/strong>&lt;br>
&lt;a href="https://github.com/raphiniert-com/ra-data-postgrest">https://github.com/raphiniert-com/ra-data-postgrest&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Demo Repository:&lt;/strong>&lt;br>
&lt;a href="https://github.com/raphiniert-com/ra-data-postgrest-demo">https://github.com/raphiniert-com/ra-data-postgrest-demo&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="fhir-data-provider">FHIR Data Provider&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Conference Publication (ICIMTH 2023):&lt;/strong>&lt;br>
&lt;a href="https://doi.org/10.3233/SHTI230436">https://doi.org/10.3233/SHTI230436&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GitLab Repository:&lt;/strong>&lt;br>
&lt;a href="https://gitlab.com/mri-tum/aiim/libs/ra-data-fhir">https://gitlab.com/mri-tum/aiim/libs/ra-data-fhir&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>NPM Package:&lt;/strong>&lt;br>
&lt;a href="https://www.npmjs.com/package/@tum-mri-aiim/ra-data-fhir">https://www.npmjs.com/package/@tum-mri-aiim/ra-data-fhir&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>OctoMap Contribution</title><link>/project/octomap/</link><pubDate>Mon, 20 Dec 2010 00:00:00 +0000</pubDate><guid>/project/octomap/</guid><description>&lt;h2 id="efficient-octree-traversal-for-robot-navigation-with-octomap">Efficient octree traversal for robot navigation with OctoMap&lt;/h2>
&lt;p>My first larger C++ project began in 2010 when I wrote my bachelor thesis in the context of OctoMap, the well known open source framework for probabilistic 3D mapping. The project marked my first real contact with C++ and introduced me to volumetric data structures, robotics concepts, and efficient tree based algorithms.&lt;/p>
&lt;p>The goal of the thesis was to investigate and accelerate octree traversal methods for ray based operations in 3D volumetric maps. Autonomous robots rely on probabilistic 3D models for collision free navigation and path planning, and OctoMap provides such models by storing occupancy information in a compressed octree structure. Insertions and updates are driven by raycasting and raytracing, which in turn depend heavily on traversal performance.&lt;/p>
&lt;p>The work explored multiple traversal strategies within OctoMap and evaluated how shortcuts, reorganized traversal orderings, and memory handling affect the speed of ray based operations. The experiments demonstrated that raytracing can be accelerated through specific traversal shortcuts, while raycasting benefits significantly from improved memory management strategies. These optimizations showed measurable gains in the insertion and update cycle of 3D sensor data.&lt;/p>
&lt;p>Building on these findings, the thesis also introduced an approach for segmenting OctoMaps into connected components of free or occupied space. Two segmentation variants were implemented and analyzed, one optimized for the compressed octree representation, and one for the expanded representation. The resulting algorithms were statistically evaluated and demonstrated how connected components could form a foundation for later object recognition or higher level map analysis.&lt;/p>
&lt;p>This project was my entry point into robotics oriented software engineering and 3D data structures, and it remains a meaningful milestone from the early days of my academic path.&lt;/p>
&lt;hr>
&lt;h2 id="links-and-resources">Links and Resources&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>OctoMap Project Homepage:&lt;/strong>&lt;br>
&lt;a href="https://octomap.github.io/">https://octomap.github.io/&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Porzellanland Schmitt GmbH</title><link>/project/porzellanland/</link><pubDate>Sat, 01 Jan 2005 00:00:00 +0000</pubDate><guid>/project/porzellanland/</guid><description>&lt;h2 id="porzellanland-schmitt-gmbh--a-family-business-shaped-by-early-digital-entrepreneurship">Porzellanland Schmitt GmbH – A Family Business Shaped by Early Digital Entrepreneurship&lt;/h2>
&lt;p>My involvement with Porzellanland began long before my academic career. As a highschool student, I accompanied my parents when they started a porcelain trading business. The seed for the business was planted in a simple everyday situation: my grandmother needed a single replacement cup from a discontinued porcelain series. My mother complained that sellers only offered complete sets. I spontaneously suggested, &amp;ldquo;Then buy the whole set, gift the parts you need, and sell the rest with profit.&amp;rdquo; That idea became the initial spark for what later grew into a full busieness.&lt;/p>
&lt;p>Very early, I became responsible for the technical backbone of the business. I set up the first online shop using osCommerce, including server installation, configuration, and the complete infrastructure needed for a functioning e-commerce platform. The limitations of osCommerce, combined with the flexibility of its open source structure and documentation, motivated me to build a fully custom shop system as part of my Abitur project. This system ran successfully for several years and formed the operational foundation of the business during its early growth.&lt;/p>
&lt;p>During my master&amp;rsquo;s studies, I migrated the shop to Magento Open Source and developed custom modules, including region-based shipping calculations and a LaTeX based PDF invoice generator. Later, the business transitioned to Shopify, where the shop continued to evolve without my direct involvement.&lt;/p>
&lt;p>Beyond the technical aspects, I also contributed to shaping the brand identity. The name Porzellanland, the domain, and the original logo were all created in collaboration with me. Over the years, the company became one of the largest specialized dealers for discontinued branded porcelain, shipping internationally and serving a niche market with high reliability.&lt;/p>
&lt;p>Today, the business is in its final chapter and planned to be dissolved at the end of the year 2025. Yet Porzellanland remains an important part of my personal and entrepreneurial story, a place where I learned early how technology, design, and business can work together, long before I entered the academic world.&lt;/p>
&lt;hr>
&lt;h2 id="links--resources">Links &amp;amp; Resources&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Porzellanland Website:&lt;/strong>&lt;br>
&lt;a href="https://porzellanland.de">https://porzellanland.de&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>